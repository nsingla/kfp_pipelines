name: "Create Kind Cluster and Run Tests"
description: "Step to set up a kind cluster and run tests against it"

inputs:
  pipeline_store:
    description: "Flag to deploy KFP with K8s Native API"
    default: 'database'
    required: false
  proxy:
    description: "If KFP should be deployed with proxy configuration"
    required: false
    default: 'false'
  cache_enabled:
    description: "If KFP should be deployed with cache enabled globally"
    required: false
    default: 'true'
  multi_user:
    description: "If KFP should be deployed in multi-user mode"
    required: false
    default: 'false'
  user_namespace:
    description: "User namespace name if KFP was deployed in multi-user mode"
    required: false
    default: 'kubeflow-user-example-com'
  default_namespace:
    description: "Default namespace when deploying KFP on a Kind Cluster"
    required: false
    default: 'kubeflow'
  python_version:
    required: false
    default: '3.9'
    description: "Python version to use"
  test_directory:
    required: true
    description: "Test Working Directory"
  num_parallel_nodes:
    required: false
    description: "Number of ginkgo nodes to run in parallel"
    default: "10"
  test_label:
    required: true
    description: "Test Label to filter on, for e.g. Regression, Smoke, APIServerTests etc."
  upload_pipelines_with_kubernetes_client:
    required: false
    default: 'false'
    description: "Set to true if you want to upload pipelines and pipeline versions with Native K8s API as CRDs"
  report_name:
    required: false
    default: ""
    description: "Override it if you want a custom name for your test report file"
  tls_enabled:
    description: "If KFP should be deployed with TLS pod-to-pod communication."
    required: false
    default: 'false'
  ca_cert_path:
    description: "Path to the CA certificate file."
    required: false
    default: ""
  # Deployment metadata inputs (from deploy action outputs)
  deployment_name:
    description: "Name of the KFP API server deployment/service (from deploy action)"
    required: false
    default: ""
  deployment_service_account_name:
    description: "Service account name from deployment (from deploy action)"
    required: false
    default: ""
  deployment_mode:
    description: "Deployment mode used - operator or direct (from deploy action)"
    required: false
    default: ""
  # Optional API overrides (for custom scenarios)
  api_url:
    description: "Override API server URL (leave empty for auto-detection)"
    required: false
    default: ""
  auth_token:
    description: "Override authentication token (leave empty for auto-generation)"
    required: false
    default: ""
  service_account_name:
    description: "Override service account name for pipeline execution (leave empty to use deployment SA)"
    required: false
    default: ""
  base_image:
    description: "Base container image for pipeline components"
    required: false
    default: "registry.redhat.io/ubi9/python-312@sha256:e80ff3673c95b91f0dafdbe97afb261eab8244d7fd8b47e20ffcbcfee27fb168"


runs:
  using: "composite"
  steps:
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ inputs.python_version }}

    - name: Configure API Access
      id: configure-api
      shell: bash
      run: |
        echo "ðŸ”§ Configuring API access for tests..."

        # Use provided API URL if available, otherwise detect from deployment
        if [ -n "${{ inputs.api_url }}" ]; then
          API_URL="${{ inputs.api_url }}"
          echo "â„¹ï¸  Using provided API URL: $API_URL"
        else
          # Auto-detect API URL based on TLS configuration
          TLS_ENABLED="${{ inputs.tls_enabled }}"
          if [ "$TLS_ENABLED" = "true" ]; then
            API_URL="https://localhost:8888"
          else
            API_URL="http://localhost:8888"
          fi
          echo "ðŸ” Auto-detected API URL: $API_URL"
        fi

        # Use provided token if available, otherwise generate from service account
        if [ -n "${{ inputs.auth_token }}" ]; then
          API_TOKEN="${{ inputs.auth_token }}"
          echo "â„¹ï¸  Using provided auth token"
        else
          # Determine service account name
          if [ -n "${{ inputs.service_account_name }}" ]; then
            SERVICE_ACCOUNT_NAME="${{ inputs.service_account_name }}"
            echo "â„¹ï¸  Using provided service account: $SERVICE_ACCOUNT_NAME"
          elif [ -n "${{ inputs.deployment_service_account_name }}" ]; then
            SERVICE_ACCOUNT_NAME="${{ inputs.deployment_service_account_name }}"
            echo "ðŸ” Using deployment service account: $SERVICE_ACCOUNT_NAME"
          else
            # Fallback based on deployment name
            DEPLOYMENT_NAME="${{ inputs.deployment_name }}"
            if [ -n "$DEPLOYMENT_NAME" ]; then
              SERVICE_ACCOUNT_NAME="$DEPLOYMENT_NAME"
              echo "ðŸ” Using deployment name as service account: $SERVICE_ACCOUNT_NAME"
            else
              SERVICE_ACCOUNT_NAME="ml-pipeline"  # Final fallback
              echo "âš ï¸  Using fallback service account: $SERVICE_ACCOUNT_NAME"
            fi
          fi

          # Wait for deployment to be ready
          DEPLOYMENT_NAME="${{ inputs.deployment_name }}"
          if [ -n "$DEPLOYMENT_NAME" ]; then
            echo "â³ Waiting for service $DEPLOYMENT_NAME to be available..."
            timeout 2m bash -c "until kubectl get service $DEPLOYMENT_NAME -n ${{ inputs.default_namespace }} &> /dev/null; do echo 'Waiting for service $DEPLOYMENT_NAME...'; sleep 10; done"
          fi

          # Generate API token
          echo "ðŸ”‘ Generating token for $SERVICE_ACCOUNT_NAME..."
          API_TOKEN=$(kubectl create token $SERVICE_ACCOUNT_NAME --namespace ${{ inputs.default_namespace }} --duration=60m)
          if [ $? -eq 0 ]; then
            echo "âœ… Token generated successfully"
          else
            echo "âŒ Token generation failed"
            exit 1
          fi
        fi

        # Output for next step
        echo "API_URL=$API_URL" >> $GITHUB_OUTPUT
        echo "API_TOKEN=$API_TOKEN" >> $GITHUB_OUTPUT
        echo "SERVICE_ACCOUNT_NAME=${SERVICE_ACCOUNT_NAME:-${{ inputs.service_account_name }}}" >> $GITHUB_OUTPUT

    - name: Run Tests
      id: run-tests
      shell: bash
      working-directory: ${{ inputs.test_directory }}
      env:
        PIPELINE_STORE: ${{ inputs.pipeline_store }}
      run: |
        USE_PROXY=${{ inputs.proxy }}
        if [ -z $USE_PROXY ]; then
            USE_PROXY='false'
        fi
        MULTI_USER=${{ inputs.multi_user}}
        if [ -z $MULTI_USER ]; then
          MULTI_USER='false'
        fi
        TLS_ENABLED=${{ inputs.tls_enabled }}
        if [ -z $TLS_ENABLED ]; then
          TLS_ENABLED='false'
        fi
        API_SCHEME='http'
        if [[ $TLS_ENABLED == 'true' ]]; then
          API_SCHEME='https'
        fi
        CA_CERT_PATH=${{ inputs.ca_cert_path }}
        if [ -z $CA_CERT_PATH ]; then
          CA_CERT_PATH=''
        fi
        PULL_NUMBER="${{ github.event.inputs.pull_number || github.event.pull_request.number }}"
        REPO_NAME="${{ github.repository }}"
        API_URL="${{ steps.configure-api.outputs.API_URL }}"
        AUTH_TOKEN="${{ steps.configure-api.outputs.API_TOKEN }}"
        SERVICE_ACCOUNT_NAME="${{ steps.configure-api.outputs.SERVICE_ACCOUNT_NAME }}"
        BASE_IMAGE="${{ inputs.base_image }}"

        go run github.com/onsi/ginkgo/v2/ginkgo -r -v --cover -p --keep-going --github-output=true --nodes=${{ inputs.num_parallel_nodes }} -v --label-filter=${{ inputs.test_label }} -- -namespace=${{ inputs.default_namespace }} -multiUserMode=$MULTI_USER -useProxy=$USE_PROXY -userNamespace=${{ inputs.user_namespace }} -uploadPipelinesWithKubernetes=${{ inputs.upload_pipelines_with_kubernetes_client}} -disableTlsCheck=true -apiScheme=$API_SCHEME -tlsEnabled=$TLS_ENABLED -caCertPath=$CA_CERT_PATH -pullNumber=$PULL_NUMBER -repoName=$REPO_NAME -apiUrl="$API_URL" -authToken="$AUTH_TOKEN" -serviceAccountName="$SERVICE_ACCOUNT_NAME" -baseImage="$BASE_IMAGE"
      continue-on-error: true

    - name: Collect Pod logs in case of Test Failures
      id: collect-logs
      shell: bash
      if: ${{ steps.run-tests.outcome != 'success' }}
      run: |
        echo "=== Current disk usage ==="
        df -h
        NAMESPACE=${{ env.NAMESPACE }}
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          NAMESPACE=${{ inputs.namespace }}
        fi
        ./.github/resources/scripts/collect-logs.sh --ns $NAMESPACE --output /tmp/tmp_pod_log.txt

    - name: Publish Test Summary
      id: publish
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: (!cancelled()) && steps.collect-logs.outcome != 'failure'
      with:
        files: |
          ${{ inputs.test_directory }}/reports/*.xml

    - name: Install Junit2Html plugin and generate report
      if: (!cancelled()) && steps.collect-logs.outcome != 'failure'
      shell: bash
      run: |
        pip install junit2html
        junit2html ${{ inputs.test_directory }}/reports/junit.xml ${{ inputs.test_directory }}/reports/test-report.html
      continue-on-error: true

    - name: Configure report name
      id: name_gen
      shell: bash
      run: |
        REPORT_NAME="HTML Report - ${{ inputs.report_name }}"
        if [ -z ${{ inputs.report_name }} ]; then
          uuid=$(uuidgen)
          REPORT_NAME="HTML Report - ${{ github.run_id }}_${{ github.job }}_$uuid"
        fi
        echo "REPORT_NAME=$REPORT_NAME" >> $GITHUB_OUTPUT

    - name: Upload HTML Report
      id: upload
      uses: actions/upload-artifact@v4
      if: (!cancelled())
      with:
        name: ${{ steps.name_gen.outputs.REPORT_NAME }}
        path: ${{ inputs.test_directory }}/reports/test-report.html
        retention-days: 30
      continue-on-error: true

    - name: Mark Workflow failure if test step failed
      if: steps.run-tests.outcome != 'success' && !cancelled()
      shell: bash
      run: exit 1

    - name: Mark Workflow failure if test reporting failed
      if: (steps.publish.outcome == 'failure' || steps.upload.outcome != 'success') && !cancelled()
      shell: bash
      run: exit 1
